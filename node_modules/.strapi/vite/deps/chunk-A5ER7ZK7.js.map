{
  "version": 3,
  "sources": ["../../../@strapi/admin/admin/src/components/GuidedTour/Provider.tsx"],
  "sourcesContent": ["import * as React from 'react';\n\nimport { produce } from 'immer';\nimport get from 'lodash/get';\nimport set from 'lodash/set';\n\nconst GUIDED_TOUR_COMPLETED_STEPS = 'GUIDED_TOUR_COMPLETED_STEPS';\nconst GUIDED_TOUR_CURRENT_STEP = 'GUIDED_TOUR_CURRENT_STEP';\nconst GUIDED_TOUR_SKIPPED = 'GUIDED_TOUR_SKIPPED';\n\nconst GUIDED_TOUR_KEYS = {\n  GUIDED_TOUR_COMPLETED_STEPS,\n  GUIDED_TOUR_CURRENT_STEP,\n  GUIDED_TOUR_SKIPPED,\n} as const;\n\n/* -------------------------------------------------------------------------------------------------\n * GuidedTourProvider\n * -----------------------------------------------------------------------------------------------*/\n\nimport { createContext } from '../Context';\n\ntype SectionKey = keyof GuidedTourContextValue['guidedTourState'];\ntype StepKey = keyof GuidedTourContextValue['guidedTourState'][SectionKey];\ntype Step = `${SectionKey}.${StepKey}`;\ninterface GuidedTourContextValue {\n  currentStep: Step | null;\n  guidedTourState: {\n    contentTypeBuilder: {\n      create: boolean;\n      success: boolean;\n    };\n    contentManager: {\n      create: boolean;\n      success: boolean;\n    };\n    apiTokens: {\n      create: boolean;\n      success: boolean;\n    };\n  };\n  isGuidedTourVisible: boolean;\n  isSkipped: boolean;\n  setCurrentStep: (step: Step | null) => void | null;\n  setGuidedTourVisibility: (isVisible: boolean) => void;\n  setSkipped: (isSkipped: boolean) => void;\n  setStepState: (step: Step, state: boolean) => void;\n  startSection: (section: SectionKey) => void;\n}\n\nconst [GuidedTourProviderImpl, useGuidedTour] = createContext<GuidedTourContextValue>('GuidedTour');\n\ninterface GuidedTourProviderProps {\n  children: React.ReactNode;\n}\n\nconst GuidedTourProvider = ({ children }: GuidedTourProviderProps) => {\n  const [{ currentStep, guidedTourState, isGuidedTourVisible, isSkipped }, dispatch] =\n    React.useReducer(reducer, initialState, initialiseState);\n\n  const setCurrentStep = (step: SetCurrentStepAction['step']) => {\n    // if step is null it is intentional, we need to dispatch it\n    if (step !== null) {\n      const isStepAlreadyDone = get(guidedTourState, step);\n      const [sectionName, stepName] = step.split('.') as [SectionKey, StepKey];\n      const sectionArray = Object.entries(guidedTourState[sectionName]);\n\n      const currentStepIndex = sectionArray.findIndex(([key]) => key === stepName);\n      const previousSteps = sectionArray.slice(0, currentStepIndex);\n\n      const isStepToShow = previousSteps.every(([, sectionValue]) => sectionValue);\n\n      if (isStepAlreadyDone || isSkipped || !isStepToShow) {\n        return null;\n      }\n    }\n\n    window.localStorage.setItem(GUIDED_TOUR_CURRENT_STEP, JSON.stringify(null));\n\n    return dispatch({\n      type: 'SET_CURRENT_STEP',\n      step,\n    });\n  };\n\n  const setGuidedTourVisibility = (value: SetGuidedTourVisibilityAction['value']) => {\n    dispatch({\n      type: 'SET_GUIDED_TOUR_VISIBILITY',\n      value,\n    });\n  };\n\n  const setStepState = (currentStep: Step, value: SetStepStateAction['value']) => {\n    addCompletedStep(currentStep);\n\n    dispatch({\n      type: 'SET_STEP_STATE',\n      currentStep,\n      value,\n    });\n  };\n\n  const startSection = (sectionName: SectionKey) => {\n    const sectionSteps = guidedTourState[sectionName];\n\n    if (sectionSteps) {\n      const guidedTourArray = Object.entries(guidedTourState);\n\n      // Find current section position in the guidedTourArray\n      // Get only previous sections based on current section position\n      const currentSectionIndex = guidedTourArray.findIndex(([key]) => key === sectionName);\n      const previousSections = guidedTourArray.slice(0, currentSectionIndex);\n\n      // Check if every steps from previous section are done\n      const isSectionToShow = previousSections.every(([, sectionValue]) =>\n        Object.values(sectionValue).every(Boolean)\n      );\n\n      const [firstStep] = Object.keys(sectionSteps) as [StepKey];\n      const isFirstStepDone = sectionSteps[firstStep];\n\n      if (isSectionToShow && !currentStep && !isFirstStepDone) {\n        setCurrentStep(`${sectionName}.${firstStep}`);\n      }\n    }\n  };\n\n  const setSkipped = (value: SetSkippedAction['value']) => {\n    window.localStorage.setItem(GUIDED_TOUR_SKIPPED, JSON.stringify(value));\n\n    dispatch({\n      type: 'SET_SKIPPED',\n      value,\n    });\n  };\n\n  return (\n    <GuidedTourProviderImpl\n      guidedTourState={guidedTourState}\n      currentStep={currentStep}\n      setCurrentStep={setCurrentStep}\n      setGuidedTourVisibility={setGuidedTourVisibility}\n      setSkipped={setSkipped}\n      setStepState={setStepState}\n      startSection={startSection}\n      // TODO: remove the future condition when the unstable guided tour will be released\n      isGuidedTourVisible={\n        isGuidedTourVisible && !window.strapi.future.isEnabled('unstableGuidedTour')\n      }\n      isSkipped={isSkipped}\n    >\n      {children}\n    </GuidedTourProviderImpl>\n  );\n};\n\ntype State = Pick<\n  GuidedTourContextValue,\n  'guidedTourState' | 'currentStep' | 'isGuidedTourVisible' | 'isSkipped'\n>;\n\nconst initialState = {\n  currentStep: null,\n  guidedTourState: {\n    contentTypeBuilder: {\n      create: false,\n      success: false,\n    },\n    contentManager: {\n      create: false,\n      success: false,\n    },\n    apiTokens: {\n      create: false,\n      success: false,\n    },\n  },\n  isGuidedTourVisible: false,\n  isSkipped: false,\n} satisfies State;\n\ninterface SetCurrentStepAction {\n  type: 'SET_CURRENT_STEP';\n  step: Step | null;\n}\n\ninterface SetStepStateAction {\n  type: 'SET_STEP_STATE';\n  currentStep: Step;\n  value: boolean;\n}\n\ninterface SetSkippedAction {\n  type: 'SET_SKIPPED';\n  value: boolean;\n}\n\ninterface SetGuidedTourVisibilityAction {\n  type: 'SET_GUIDED_TOUR_VISIBILITY';\n  value: boolean;\n}\n\ntype Action =\n  | SetCurrentStepAction\n  | SetStepStateAction\n  | SetSkippedAction\n  | SetGuidedTourVisibilityAction;\n\nconst reducer: React.Reducer<State, Action> = (state: State = initialState, action: Action) =>\n  produce(state, (draftState) => {\n    switch (action.type) {\n      case 'SET_CURRENT_STEP': {\n        draftState.currentStep = action.step;\n        break;\n      }\n      case 'SET_STEP_STATE': {\n        const [section, step] = action.currentStep.split('.') as [SectionKey, StepKey];\n        draftState.guidedTourState[section][step] = action.value;\n        break;\n      }\n      case 'SET_SKIPPED': {\n        draftState.isSkipped = action.value;\n        break;\n      }\n      case 'SET_GUIDED_TOUR_VISIBILITY': {\n        draftState.isGuidedTourVisible = action.value;\n        break;\n      }\n      default: {\n        return draftState;\n      }\n    }\n  });\n\nconst initialiseState = (initialState: State) => {\n  const copyInitialState = { ...initialState };\n  const guidedTourLocaleStorage = JSON.parse(\n    window.localStorage.getItem(GUIDED_TOUR_COMPLETED_STEPS) ?? '[]'\n  );\n  const currentStepLocaleStorage = JSON.parse(\n    window.localStorage.getItem(GUIDED_TOUR_CURRENT_STEP) ?? 'null'\n  );\n  const skippedLocaleStorage = JSON.parse(\n    window.localStorage.getItem(GUIDED_TOUR_SKIPPED) ?? 'null'\n  );\n\n  if (Array.isArray(guidedTourLocaleStorage)) {\n    guidedTourLocaleStorage.forEach((step) => {\n      const [sectionName, stepName] = step.split('.');\n      set(copyInitialState, ['guidedTourState', sectionName, stepName], true);\n    });\n  }\n\n  // if current step when initializing mark it as done\n  if (currentStepLocaleStorage) {\n    const [sectionName, stepName] = currentStepLocaleStorage.split('.') as [SectionKey, StepKey];\n    set(copyInitialState, ['guidedTourState', sectionName, stepName], true);\n\n    addCompletedStep(currentStepLocaleStorage as Step);\n\n    window.localStorage.setItem(GUIDED_TOUR_CURRENT_STEP, JSON.stringify(null));\n  }\n\n  if (skippedLocaleStorage !== null) {\n    set(copyInitialState, 'isSkipped', skippedLocaleStorage);\n  }\n\n  return copyInitialState;\n};\n\n/**\n * @description Add a completed step to the local storage if it does not already exist.\n */\nconst addCompletedStep = (completedStep: Step) => {\n  const currentSteps = JSON.parse(window.localStorage.getItem(GUIDED_TOUR_COMPLETED_STEPS) ?? '[]');\n\n  if (!Array.isArray(currentSteps)) {\n    return;\n  }\n\n  const isAlreadyStored = currentSteps.includes(completedStep);\n\n  if (isAlreadyStored) {\n    return;\n  }\n\n  window.localStorage.setItem(\n    GUIDED_TOUR_COMPLETED_STEPS,\n    JSON.stringify([...currentSteps, completedStep])\n  );\n};\n\nexport { GuidedTourProvider, useGuidedTour, GuidedTourContextValue, GUIDED_TOUR_KEYS };\n"],
  "mappings": "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",
  "names": ["GUIDED_TOUR_COMPLETED_STEPS", "GUIDED_TOUR_CURRENT_STEP", "GUIDED_TOUR_SKIPPED", "GuidedTourProviderImpl", "useGuidedTour", "createContext", "GuidedTourProvider", "children", "currentStep", "guidedTourState", "isGuidedTourVisible", "isSkipped", "dispatch", "useReducer", "reducer", "initialState", "initialiseState", "setCurrentStep", "step", "isStepAlreadyDone", "get", "sectionName", "stepName", "split", "sectionArray", "Object", "entries", "currentStepIndex", "findIndex", "key", "previousSteps", "slice", "isStepToShow", "every", "sectionValue", "window", "localStorage", "setItem", "JSON", "stringify", "type", "setGuidedTourVisibility", "value", "setStepState", "addCompletedStep", "startSection", "sectionSteps", "guidedTourArray", "currentSectionIndex", "previousSections", "isSectionToShow", "values", "Boolean", "firstStep", "keys", "isFirstStepDone", "setSkipped", "_jsx", "strapi", "future", "isEnabled", "contentTypeBuilder", "create", "success", "contentManager", "apiTokens", "state", "action", "produce", "draftState", "section", "copyInitialState", "guidedTourLocaleStorage", "parse", "getItem", "currentStepLocaleStorage", "skippedLocaleStorage", "Array", "isArray", "forEach", "set", "completedStep", "currentSteps", "isAlreadyStored", "includes"]
}
